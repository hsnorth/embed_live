<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Blog Posts Embed</title>
    <link rel="stylesheet" href="embed-style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Noto+Serif:wght@400;700&family=Noto+Sans:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <main>
        <section class="live-blog-posts">
            <div id="postsContainer">
                <p>Loading live blog...</p>
            </div>
        </section>
        <div id="loadMoreContainer"></div>
    </main>

    <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
    <script async src="//www.instagram.com/embed.js"></script>
    <script async src="https://www.tiktok.com/embed.js"></script>
    <script async src="https://embed.redditmedia.com/widgets/platform.js" charset="UTF-8"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js";
        import { getFirestore, collection, query, orderBy, where, onSnapshot, getDocs } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-firestore.js";
    
        const firebaseConfig = {
            apiKey: "AIzaSyDrJsFAJDU4EMficerN2TvOJlio6SYh6lk",
            authDomain: "myliveblogapp-cf9df.firebaseapp.com",
            projectId: "myliveblogapp-cf9df",
            storageBucket: "myliveblogapp-cf9df.appspot.com",
            messagingSenderId: "324824649312",
            appId: "1:324824649312:web:c0750693346091d853bd05",
        };
    
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
    
        // --- STATE MANAGEMENT ---
        let currentBlogId = null;
        let allPosts = []; // Local cache of all posts from the database
        let postsVisibleCount = 0;
        const INITIAL_POST_COUNT = 20;
        const LOAD_MORE_COUNT = 15;
        let unsubscribe = null; 
        let isInitialLoad = true; // Flag to handle the first data fetch
        let allWidgets = {}; // Cache for widgets, keyed by ID for quick lookup
    
        const postsContainer = document.getElementById('postsContainer');
        const loadMoreContainer = document.getElementById('loadMoreContainer');
        
        // --- NEW: Event listener for "Show More" / "Show Less" buttons ---
        postsContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('toggle-content-button')) {
                const button = e.target;
                const postCard = button.closest('.post-card');
                const postText = postCard.querySelector('.post-text.expandable');

                if (postText) {
                    const isExpanded = postText.classList.toggle('expanded');
                    button.textContent = isExpanded ? 'Show Less' : 'Show More';
                    
                    // After content size changes, we need to inform the parent iframe to resize
                    if (window.parent) {
                        // Wait for CSS transition to finish for accurate height
                        setTimeout(() => {
                            const height = document.body.scrollHeight;
                            window.parent.postMessage({ type: 'iframeHeight', height: height + 20 }, '*');
                        }, 400); // Match the longest transition time in CSS
                    }
                }
            }
        });

        function timeAgo(timestamp) {
            if (!timestamp || typeof timestamp.toDate !== 'function') return '';
            const now = new Date();
            const postDate = timestamp.toDate();
            const seconds = Math.floor((now - postDate) / 1000);
            if (seconds < 60) return `${seconds}s ago`;
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            const days = Math.floor(hours / 24);
            return `${days}d ago`;
        }
    
        // NEW: Function to render widget HTML
        function renderWidget(widget) {
            if (!widget) return '';
            let widgetHtml = `<div class="embedded-widget widget-type-${widget.type}">`;
            if (widget.name) {
                widgetHtml += `<h3 class="widget-title">${widget.name}</h3>`;
            }
            if (widget.subtitle) {
                widgetHtml += `<p class="widget-subtitle">${widget.subtitle}</p>`;
            }
            if (widget.content) {
                widgetHtml += `<div class="widget-content">${widget.content}</div>`;
            }
            if (widget.footer) {
                widgetHtml += `<p class="widget-footer">${widget.footer}</p>`;
            }
            widgetHtml += `</div>`;
            return widgetHtml;
        }

        function createPostCard(post) {
            const postCard = document.createElement('div');
            postCard.className = 'post-card';
            postCard.dataset.postId = post.id;
            postCard.id = `post-${post.id}`;
    
            let pinnedIndicatorHtml = '';
            if (post.isPinned) {
                postCard.classList.add('pinned');
                pinnedIndicatorHtml = `<div class="pinned-indicator"><i class="fas fa-thumbtack"></i> PINNED</div>`;
            }
    
            const avatarUrl = post.authorAvatar || 'https://hsnorth.github.io/embed_live/live/harry.png';
            const subtitleHtml = post.subtitle ? `<p class="post-subtitle">${post.subtitle}</p>` : '';
            let fullContentHtml = post.content || ''; 
            const reportingFromDisplay = (post.reportingFrom && !post.hideReportingFrom) ? `<span>${post.reportingFrom}</span>` : '';
            const timeAgoHtml = post.isPinned ? '' : `<span class="bullet">â€¢</span> <span class="time-ago">${timeAgo(post.timestamp)}</span>`;
    
            let mediaHtml = '';
            if (post.mediaUrl) {
                if (post.mediaType?.startsWith('image')) {
                    mediaHtml = `<img src="${post.mediaUrl}" alt="Post Image" class="post-media">`;
                } else if (post.mediaType?.startsWith('video')) {
                    mediaHtml = `<video src="${post.mediaUrl}" poster="${post.mediaUrl}#t=0.1" class="post-media post-video" controls playsinline disablePictureInPicture preload="metadata"></video>`;
                }
            }
            
            // NEW: Process widget placeholders in post content
            const widgetRegex = /<!--WIDGET::([^:]+)::([^:]+)-->/g;
            fullContentHtml = fullContentHtml.replace(widgetRegex, (match, widgetId, widgetPosition) => {
                const widget = allWidgets[widgetId];
                // Widget position is handled by the overall rendering logic, not within the post content itself
                // So, we just return the widget HTML if it's found.
                return widget ? renderWidget(widget) : '';
            });

            // --- NEW: Logic for "Show More" button ---
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = fullContentHtml;
            const textLength = tempDiv.textContent.length;
            const characterLimit = 450;

            let postTextHtml;
            let showMoreButtonHtml = '';

            if (textLength > characterLimit) {
                postTextHtml = `<div class="post-text expandable">${fullContentHtml}</div>`;
                showMoreButtonHtml = `<button class="toggle-content-button">Show More</button>`;
            } else {
                postTextHtml = `<div class="post-text">${fullContentHtml}</div>`;
            }

            postCard.innerHTML = `
                ${pinnedIndicatorHtml}
                <div class="post-header-line">
                    <div class="author-avatar"><img src="${avatarUrl}" alt="Author Avatar" class="author-avatar-img"></div>
                    <div class="post-meta">
                        <div class="meta-line-one"><strong>${post.authorName || 'Anonymous'}</strong>${timeAgoHtml}</div>
                        ${reportingFromDisplay ? `<span class="reporting-from">${reportingFromDisplay}</span>` : ''}
                    </div>
                </div>
                ${subtitleHtml}
                ${postTextHtml}
                ${mediaHtml}
                ${showMoreButtonHtml}
            `;
    
            return postCard;
        }
    
        function renderSocialEmbeds() {
            if (typeof twttr === 'object' && typeof twttr.widgets.load === 'function') twttr.widgets.load(postsContainer);
            if (typeof instgrm === 'object' && typeof instgrm.Embeds.process === 'function') instgrm.Embeds.process();
            if (typeof tiktok_embed === 'object') tiktok_embed.load();
            if (typeof redditEmbed === 'object' && typeof redditEmbed.render === 'function') redditEmbed.render();
            
            if (window.parent) {
                setTimeout(() => {
                    const height = document.body.scrollHeight;
                    window.parent.postMessage({ type: 'iframeHeight', height: height + 20 }, '*');
                }, 500);
            }
        }
    
        // This function now handles the initial display and full refreshes,
        // including dynamic widget insertion based on position.
        function displayPosts(postsToRender) {
            postsContainer.innerHTML = ''; // Clear previous content
            if (postsToRender.length === 0) {
                 postsContainer.innerHTML = '<p class="no-posts-message">No posts yet for this live blog.</p>';
                 return;
            }

            let renderedPostsCount = 0;
            const postsAndWidgets = []; // Array to hold interleaved posts and widgets

            // First, add all posts to the interleaved array
            postsToRender.forEach(post => {
                postsAndWidgets.push({ type: 'post', data: post });
            });

            // Now, iterate through all posts (including those not yet rendered) to find widget positions
            allPosts.forEach((post, index) => {
                const widgetRegex = /<!--WIDGET::([^:]+)::([^:]+)-->/g;
                let match;
                while ((match = widgetRegex.exec(post.content)) !== null) {
                    const widgetId = match[1];
                    const widgetPosition = match[2];
                    const widget = allWidgets[widgetId];

                    if (widget) {
                        let insertIndex;
                        if (widgetPosition === '' || isNaN(parseInt(widgetPosition))) {
                            // If position is empty or not a number, insert at the end of all *currently loaded* posts
                            insertIndex = postsToRender.length; 
                        } else {
                            // Insert after the specified post number (1-indexed)
                            insertIndex = parseInt(widgetPosition);
                        }
                        
                        // Ensure insertIndex is within bounds of currently displayed posts
                        insertIndex = Math.min(insertIndex, postsToRender.length);
                        insertIndex = Math.max(0, insertIndex);

                        // Add widget to the interleaved array. 
                        // We need to be careful about duplicates if a post is edited and re-saved.
                        // For simplicity, we'll just add it, but in a more complex app, you might
                        // want to track which widgets have already been added to avoid duplicates.
                        postsAndWidgets.splice(insertIndex, 0, { type: 'widget', data: widget, originalPostId: post.id });
                    }
                }
            });

            // Filter out duplicate widgets if they were inserted multiple times from different posts
            // This is a simple deduplication based on widget ID and position.
            const uniquePostsAndWidgets = [];
            const addedWidgets = new Set(); // Stores 'widgetId-position'
            const addedPosts = new Set(); // Stores 'postId'

            postsAndWidgets.forEach(item => {
                if (item.type === 'post') {
                    if (!addedPosts.has(item.data.id)) {
                        uniquePostsAndWidgets.push(item);
                        addedPosts.add(item.data.id);
                    }
                } else if (item.type === 'widget') {
                    const widgetKey = `${item.data.id}-${item.data.position || 'end'}`;
                    if (!addedWidgets.has(widgetKey)) {
                        uniquePostsAndWidgets.push(item);
                        addedWidgets.add(widgetKey);
                    }
                }
            });

            // Render the interleaved content
            uniquePostsAndWidgets.forEach(item => {
                if (item.type === 'post') {
                    const postCard = createPostCard(item.data);
                    postsContainer.appendChild(postCard);
                } else if (item.type === 'widget') {
                    const widgetElement = document.createElement('div');
                    widgetElement.innerHTML = renderWidget(item.data);
                    postsContainer.appendChild(widgetElement);
                }
            });

            renderSocialEmbeds();
        }
    
        // --- MODIFIED FUNCTION ---
        // The "Load More" button's click event now uses appendPosts.
        function updateLoadMoreButton() {
            loadMoreContainer.innerHTML = ''; // Clear existing button
            if (postsVisibleCount < allPosts.length) {
                const loadMoreButton = document.createElement('button');
                loadMoreButton.textContent = 'Load More Posts';
                loadMoreButton.className = 'load-more-button';
                loadMoreButton.addEventListener('click', () => {
                    const startIndex = postsVisibleCount; // The index of the first new post
                    postsVisibleCount = Math.min(postsVisibleCount + LOAD_MORE_COUNT, allPosts.length);
                    const postsToAppend = allPosts.slice(startIndex, postsVisibleCount);
    
                    // Use the new display function for a full re-render including widgets
                    displayPosts(postsToAppend); 
                    updateLoadMoreButton(); // Check if the button is still needed
                });
                loadMoreContainer.appendChild(loadMoreButton);
            }
        }

        // NEW: Function to load all widgets initially
        const loadAllWidgets = async () => {
            try {
                const q = query(collection(db, 'widgets')); // Fetch all widgets
                const querySnapshot = await getDocs(q);
                allWidgets = {}; // Reset cache
                querySnapshot.forEach(doc => {
                    allWidgets[doc.id] = doc.data();
                });
                console.log("Loaded widgets:", allWidgets);
            } catch (error) {
                console.error("Error loading all widgets:", error);
            }
        };
        
        async function initializeLiveBlogListener() {
            if (unsubscribe) unsubscribe(); 

            // Load all widgets before setting up the post listener
            await loadAllWidgets();
    
            const q = query(collection(db, 'posts'), where('blogId', '==', currentBlogId), orderBy('timestamp', 'desc'));
    
            unsubscribe = onSnapshot(q, (snapshot) => {
                const previousPostCount = allPosts.length;
                let freshPosts = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    
                const pinnedPostIndex = freshPosts.findIndex(p => p.isPinned === true);
                if (pinnedPostIndex > -1) {
                    const [pinnedPost] = freshPosts.splice(pinnedPostIndex, 1);
                    freshPosts.unshift(pinnedPost); 
                }
                
                allPosts = freshPosts; 
    
                // The logic for displaying posts on new updates remains the same,
                // which correctly handles pinning and prepending new posts.
                if (isInitialLoad) {
                    postsVisibleCount = Math.min(INITIAL_POST_COUNT, allPosts.length);
                    isInitialLoad = false;
                } else {
                    const newPostCount = allPosts.length - previousPostCount;
                    if (newPostCount > 0) {
                        postsVisibleCount += newPostCount;
                    }
                }
                
                const postsToDisplay = allPosts.slice(0, postsVisibleCount);
                displayPosts(postsToDisplay); // Full refresh for real-time updates
                updateLoadMoreButton();
    
            }, (error) => {
                console.error("Error with real-time listener:", error);
                postsContainer.innerHTML = '<p class="error-message">Could not load live updates. Please check the console for errors.</p>';
            });
        }
    
        document.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            currentBlogId = urlParams.get('blogId');
            if (!currentBlogId) {
                postsContainer.innerHTML = '<p class="error-message">Error: Blog ID not found in URL.</p>';
                return;
            }
            initializeLiveBlogListener();
        });
    
    </script>
</body>
</html>
